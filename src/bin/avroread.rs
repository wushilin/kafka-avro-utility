use clap::Parser;
use humansize::{format_size, DECIMAL};
use kafka_avro_utility::avrofile::load_avro_file;
use std::path::PathBuf;
use apache_avro::types::Value;

#[derive(Parser, Debug)]
#[command(name = "avroread")]
#[command(about = "Read and print Avro records from a file generated by avrogen")]
struct Args {
    /// Input file path
    #[arg(long, required = true)]
    in_file: PathBuf,

    #[arg(long, default_value_t = false)]
    print: bool,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    let (schema_str, _schema, mut iterator) = load_avro_file(&args.in_file)?;

    println!("Schema loaded: {}", schema_str);

    let mut count = 0;
    while let Some(record) = iterator.next() {
        match record {
            Ok(value) => {
                if args.print {
                    println!("Record {}:", count + 1);
                    print_avro_value(&value, 1);
                }
                count += 1;
                if count % 10000 == 0 {
                    println!(
                        "Processed {} records (Uncompressed: {})...",
                        count,
                        format_size(iterator.total_bytes_read, DECIMAL)
                    );
                }
            }
            Err(e) => {
                eprintln!("Error reading record {}: {}", count + 1, e);
                break;
            }
        }
    }

    let file_size = std::fs::metadata(&args.in_file)?.len();
    let ratio = if file_size > 0 {
        iterator.total_bytes_read as f64 / file_size as f64
    } else {
        0.0
    };

    println!(
        "Total records read: {}\nTotal Uncompressed: {}\nCompressed File Size: {}\nCompression Ratio: {:.2}x",
        count,
        format_size(iterator.total_bytes_read, DECIMAL),
        format_size(file_size, DECIMAL),
        ratio
    );

    Ok(())
}

fn print_avro_value(value: &Value, indent: usize) {
    let indent_str = "  ".repeat(indent);
    match value {
        Value::Record(fields) => {
            println!("{{");
            for (name, val) in fields {
                print!("{}  {}: ", indent_str, name);
                print_avro_value(val, indent + 1);
            }
            println!("{}}}", indent_str);
        }
        Value::Array(items) => {
            println!("[");
            for item in items {
                print!("{}  ", indent_str);
                print_avro_value(item, indent + 1);
            }
            println!("{}]", indent_str);
        }
        Value::Map(items) => {
            println!("{{");
            for (key, val) in items {
                print!("{}  {:?}: ", indent_str, key);
                print_avro_value(val, indent + 1);
            }
            println!("{}}}", indent_str);
        }
        Value::Union(_idx, val) => {
            // Transparently print inner value
            print_avro_value(val, indent);
        }
        Value::Null => println!("null"),
        Value::Boolean(b) => println!("{}", b),
        Value::Int(i) => println!("{}", i),
        Value::Long(i) => println!("{}", i),
        Value::Float(f) => println!("{}", f),
        Value::Double(f) => println!("{}", f),
        Value::Bytes(b) => {
            // Print as hex if reasonably short, else summary
            if b.len() <= 32 {
                print!("0x");
                for byte in b {
                    print!("{:02x}", byte);
                }
                println!();
            } else {
                println!("Bytes({} bytes)", b.len());
            }
        }
        Value::String(s) => println!("{:?}", s), // Debug print adds quotes
        Value::Fixed(_, b) => {
             print!("0x");
             for byte in b {
                 print!("{:02x}", byte);
             }
             println!();
        }
        Value::Enum(_, s) => println!("{}", s),
        Value::Uuid(u) => println!("{}", u),
        Value::Date(d) => println!("Date({})", d),
        Value::TimestampMillis(t) => println!("TimestampMillis({})", t),
        Value::TimestampMicros(t) => println!("TimestampMicros({})", t),
        Value::Duration(d) => println!("{:?}", d),
        Value::Decimal(d) => println!("{:?}", d),
        // Fallback for any new types
        v => println!("{:?}", v),
    }
}
